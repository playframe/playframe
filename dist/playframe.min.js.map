{"version":3,"file":"playframe.min.js","sources":["../node_modules/@playframe/oversync/index.js","../node_modules/@playframe/evolve/index.js","../node_modules/@playframe/statue/index.js","../node_modules/@playframe/component/index.js","../node_modules/@playframe/h/index.js","../node_modules/@playframe/shadom/index.js","../node_modules/@playframe/router/index.js","../index.js"],"sourcesContent":["// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # OverSync\n\n// ###### 0.4 kB Frame Rendering Engine\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/oversync\n// ```\n\n// ## Functionality Overview\n// ```js\n// import oversync from '@playframe/oversync'\n\n// const sync = oversync(Date.now, requestAnimationFrame)\n// ```\n\n// Each method schedules given function\n// to be executed in specific time and order\n\n// ```js\n// sync.next(fn) // events handling and dom read\n// sync.catch(fn) // error handling\n// sync.then(fn) // data work is done here\n// sync.finally(fn) // finilizing data\n// sync.render(fn) // dom manipulation\n\n// // Actual requestAnimationFrame callback\n// // No work should be done here\n// sync.frame(fn)\n// ```\n\n// #### Execution strategy\n// Render a frame_0 first,\n// then request a new frame_1 and immediately do work.\n// After work is done VM is idling for up to 10ms\n// until frame callback is fired and frame_1 finally rendered.\n// Any event occuring after work is done\n// but before frame_1 is rendered will schedule actual work\n// to be done onlly after frame_1 is rendered\n\n// ```\n// 1ms Request frame_0 and setTimeout(work_for_frame_1)\n// 2ms frame_0 is rendered by browser\n// 3ms Request frame_1\n// 4ms work_for_frame_1: read dom, do work, write dom\n// ... idle\n// 8ms Click: sync.next(click_handler) for frame_2\n// ... idle\n// 10ms Fetch: sync.then(fetch_handler) for frame_2\n// ...idle\n// 15ms Animation callback: setTimeout(work_for_frame_2)\n// 16ms frame_1 is rendered\n// 17ms Request frame_2\n// 18ms work_for_frame_2: read dom, do work, write dom\n// ...\n// ```\n\n// ## Annotated Source\n// Let's define a higher order function\n// that would take a `now` timestamp function,\n// scheduling `next` function and optionally\n// a list `steps` of desired execution order and method names\n// and an optional `step` method name.\nvar delta, pusher, runner, scheduler;\n\nmodule.exports = (now, next, steps = ['next', 'catch', 'then', 'finally', 'render'], step = 'frame') => {\n  var delta_runner, push_and_run, schedule, step_ops, steps_ops, sync;\n  // For each step we would prepare and empty array\n  step_ops = [];\n  steps_ops = steps.map(() => {\n    return [];\n  });\n  // For measuring time deltas we would have a fancy runner function\n  delta_runner = delta(now)(runner);\n  // `schedule` function for requesting next frame\n  // in which we would run our `frame` operations and\n  // schedule work for the rest of the steps\n  schedule = scheduler(next)(() => {\n    var run;\n    run = delta_runner();\n    run(step_ops);\n    return setTimeout(() => {\n      return steps_ops.forEach(run);\n    });\n  });\n  // A pusher function that will `schedule` on every push\n  push_and_run = pusher(schedule);\n  // Dynamically creating methods that would push operations\n  // and schedule execution and returning `sync`\n  sync = {};\n  sync[step] = push_and_run(step_ops);\n  steps.forEach((step, i) => {\n    return sync[step] = push_and_run(steps_ops[i]);\n  });\n  return sync;\n};\n\n// #### Abstract functions\n\n// Our `scheduler` is creating a throttled `schedule`\nscheduler = (next) => {\n  return (f) => {\n    var _scheduled, g;\n    _scheduled = false;\n    g = (x) => {\n      _scheduled = false;\n      return f(x);\n    };\n    return () => {\n      if (!_scheduled) {\n        _scheduled = true;\n        next(g);\n      }\n    };\n  };\n};\n\n// This `pusher` is creating a function that will run `task`\n// before pushing `op` to `ops`\npusher = (task) => {\n  return (ops) => {\n    return (op) => {\n      task();\n      ops.push(op);\n    };\n  };\n};\n\n// Feeding timestamps produced by `now` to a given `f`\n// like our `runner`\ndelta = (now) => {\n  return (f) => {\n    var _prev_ts;\n    _prev_ts = now();\n    return () => {\n      var ts;\n      return f({\n        delta: (ts = now()) - _prev_ts,\n        ts: (_prev_ts = ts)\n      });\n    };\n  };\n};\n\n// This runner will feed `x` to a list of given `ops`.\n// It will recover if any operation fails.\n// Clearing `ops` list at the end\nrunner = (x) => {\n  return (ops) => {\n    var e, i, length, recover;\n    i = 0;\n    // Rechecking length in outer loop\n    // could push more ops while running\n    while (i < (length = ops.length)) {\n      try {\n        while (i < length) {\n          ops[i++](x);\n        }\n      } catch (error) {\n        e = error;\n        console.error(e);\n        if (recover = ops[i - 1].r) { // recovering\n          recover(e);\n        }\n      }\n    }\n    ops.length = 0; // mutating ðŸ‘¹\n  };\n};\n","// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # Evolve\n\n// ###### 0.16 kB Deep calling assign\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/evolve\n// ```\n\n// ## Usage\n// ```js\n// import evolve from '@playframe/evolve'\n\n// const props = {onclick: (event)=> fetch()}\n\n// const clickLogger = { onclick: (handler)=>(e)=>\n//   console.log(e)\n//   handler && handler(e);\n// }\n\n// const loggedClicksProps = evolve(props, clickLogger);\n// ```\n\n// ## Annotated Source\n\n// Caching `Array.isArray` for perf\nvar evolve, isArray;\n\n({isArray} = Array);\n\n// Exporting a deep assign that passes old values to functions\nmodule.exports = evolve = (base, upgrade) => {\n  var evolved, k, type, v;\n  evolved = {...base};\n  for (k in upgrade) {\n    v = upgrade[k];\n    type = typeof v;\n    evolved[k] = type === 'function' ? v(base[k]) : type === 'object' && !isArray(v) ? evolve(base[k], v) : v;\n  }\n  return evolved;\n};\n","// Generated by CoffeeScript 2.3.2\n  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n  // # Statue\n\n  // ###### 0.4 kb Art of functional State\n\n  // ## Installation\n  // ```sh\n  // npm install --save @playframe/statue\n  // ```\n\n  // ## Description\n  // Statue is a [Redux](https://github.com/reduxjs/redux)\n  // like functional state manegement library that lets you define\n  // and access actions right inside of your state. So you could\n  // describe a deeply nested state tree with nested actions\n  // in one simple object.\n\n  // To update state, action could return a new object\n  // that has one or more properties.\n  // This will produce a new state with those properties updated.\n\n  // Another option is to mutate a state object passed to your function.\n  // Mutation will be detected and this will produce a new state as well.\n  // Returned value is ignored in this case.\n  // If you are writing a performance demanding reducer,\n  // please use this mutation trick and define the hottest property as\n  // the first one in your initial state for faster checking.\n\n  // If you don't want to update state, please make sure you action\n  // returns something\n  // [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)\n  // or the same state that was passed to it\n\n  // To work with state directly you can do\n  // ```js\n  // // to update the state\n  // state._(updated)\n\n  // // to read the latest state\n  // state = state._()\n\n  // // to turn a function into a reducer\n  // state._.new_action = state._( (x, state)=> state.x = x )\n  // ```\n  //  Statue also cares not to send too many updates\n  // from child to parent branches\n  // ## Usage\n  // ```js\n  // import statue from '@playframe/statue'\n  // const state = statue({\n  //   i: 0,\n  //   _: {\n  //     increment: (x, state)=> i: state.i + 1,\n  //     incrementBy: (n)=>(event, state)=> state.i += n // mutating\n  //   },\n  //   subState: {\n  //     i: 0,\n  //     _: {\n  //       increment: (x, state)=> i: state.i + 1\n  //     }\n  //   }\n  //   },\n  //   setTimeout,\n  //   (newState)=> {\n  //     console.log('Counter is:', newState.i)\n  //     console.log('Subcounter is:', newState.subState.i)\n  //   }\n  // )\n  // for(let j = 0; j < 100; j++){\n  //   state.subState._.increment()\n  //   state.subState._.increment()\n  //   state._.increment()\n  // }\n  // // Logs only once\n  // //> Counter is: 100\n  // //> Subcounter is: 200\n  // // Will increment by 10 and log in console on every click\n  // $('button').click( state._.incrementBy(10) )\n  // ```\n  // ## Annotated Source\n  // Caching static functions from `Object`\nvar assign, create, is_function, keys, statue,\n  hasProp = {}.hasOwnProperty;\n\n({assign, create, keys} = Object);\n\nis_function = (f) => {\n  return typeof f === 'function';\n};\n\n// Let's define a function that takes a takes `state_actions`\n// as an initial state and its reducers (actions)\n// defined under `_` (underscore) property.\n// Our function also takes `level_up` or 'subscribe' function\n// that will be called when state updates. Most sertainly we don't\n// want to update the whole state tree every time nested leaf updates,\n// so we also pass a `delayed` function that will help debounce\n// parent update\nmodule.exports = statue = (state_actions, delayed, level_up) => {\n  /*                       state._.actions\n                                 ]_[.state._.actions\n                                 [_]      ]_[.\n                                 [_]      [_]\n  */\n  var _nested, _scheduled, _state, action, actions, delay_nested, inject_state, k, reset, save_state, schedule, update_parent, update_state, v;\n  actions = state_actions._;\n  _state = state_actions; // _closure\n  _scheduled = false; // _closure\n  _nested = reset = () => {\n    return _nested = reset; // reset _nested\n  };\n\n  // delaying child state updates\n  delay_nested = (f) => {\n    _nested = ((_nested) => {\n      return () => {\n        _nested();\n        f();\n      };\n    })(_nested);\n    schedule();\n  };\n// recursive statue if there nested actions\n  for (k in state_actions) {\n    v = state_actions[k];\n    if (v._) {\n      _state[k] = statue(v, delay_nested, ((k) => {\n        return (sub_state) => { // closure for k\n          return _state[k] = sub_state; // executes as _nested\n        };\n      })(k));\n    }\n  }\n\n  // saving new state in closure\n  save_state = (state) => {\n    schedule();\n    return _state = state;\n  };\n  schedule = () => {\n    if (!_scheduled) {\n      _scheduled = true;\n      // lazy parent update\n      delayed(update_parent);\n    }\n  };\n  update_parent = () => {\n    var proto_state;\n    _scheduled = false;\n    proto_state = _state;\n    _state = create(null);\n    for (k in proto_state) {\n      // merging prototype chain state\n      _state[k] = proto_state[k];\n    }\n    _nested();\n    level_up(_state);\n  };\n  // This function is a little overloaded, it's a getter/setter but\n  // also is a function wrapper.\n  // You can access it like this `yourState._(updated)`.\n  // The wrapper will return a twin of your function\n  // that calls yours and passes a copy of latest state\n  // as the second argument. State will update, if the copy is mutated\n  // or a new object returned. If your function\n  // returns a new function, it will be wrapped in the same manner.\n  // So we support state updates for deeply curried functions.\n\n  // curry down or make state\n  _state._ = update_state = (arg) => {\n    if (is_function(arg)) {\n      return inject_state(arg);\n    } else {\n      if (arg) {\n        return save_state(assign(create(_state), arg));\n      } else {\n        return _state;\n      }\n    }\n  };\n  // `inject_state` is a higher order function that does the magic.\n  // It produces a cheap clone if current state by setting current\n  // state as its prototype. Please note that such a clone has no\n  // own properties, and all property accees falls back to its\n  // prototype. If we mutate such a clone, new properties are\n  // easily detected\n  inject_state = (f) => {\n    return (x) => {\n      var cloned, mutated, y;\n      // _state as prototype of cloned\n      cloned = create(_state);\n      y = f(x, cloned);\n      for (k in cloned) {\n        if (!hasProp.call(cloned, k)) continue;\n        // mutation detected\n        mutated = true;\n        save_state(cloned);\n        break;\n      }\n      if (is_function(y)) {\n        // recursevely currying down\n        return inject_state(y);\n      } else {\n        if (y && !mutated && y !== cloned && !y.then) { // not promise\n          save_state(assign(cloned, y));\n        }\n        return y;\n      }\n    };\n  };\n// Now let's wrap all of your actions and set under the `_` property.\n// That's it! You new state machine is ready!\n\n// bind actions to state\n  for (k in actions) {\n    action = actions[k];\n    update_state[k] = inject_state(action);\n  }\n  return _state;\n};\n","// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # Component\n\n// ###### 0.3 kB Pure Stateful Styled Components\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/component\n// ```\n\n// ## Description\n// Pure Functional Styled Web Components for\n// [PlayFrame](https://github.com/playframe/playframe). Components are\n// rendered independetly from the rest of the app. By using\n// [Shadow DOM](https://developers.google.com/web/fundamentals/web-components/shadowdom)\n// provided by\n// [ShaDOM](https://github.com/playframe/shadom)\n// we achieve scoped styling and simple css selectors.\n// Please consider using\n// [CSS Variables](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables)\n// for maximum animation performance and flexibility.\n\n// You can create instances manually and keep them in parent state or\n// you can register them with `fp.use` or `h.use` and create them dynamically.\n// To be able to identify the same dynamic component we use a unique\n// object `mkey` as a\n// [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\n// key. For a `UserView` Component actual `user` object would be a perfect\n// WeakMap key\n\n// ## Usage\n// ```js\n// import h from '@playframe/h'\n// import oversync from '@playframe/oversync'\n// import component from '@playframe/component'\n\n// const sync = oversync(Date.now, requestAnimationFrame)\n// const Component = component(sync)\n\n// export default myCounter = (Component)=>\n//   Component({\n//     seconds: 0,\n//     _: {\n//       reset: ()=> {seconds: 0}\n//       increment: (x, state)=> {\n//         state.seconds++\n//         setTimeout( state._.increment,\n//           (1000 - Date.now() % 1000) || 1000 )\n//       }\n//     }\n//   })((state)=>\n//     <my-counter style={ {'--border': state.border} }>\n//       <style>{`\n//         :host {\n//           display: block;\n//           border: var(--border, 0);\n//         }\n//       `}</style>\n//       <div>\n//         {props.children}\n//         <br/>\n//         {state.seconds} seconds passed\n//         <br/>\n//         <button onclick={state._.reset}> Reset </button>\n//       </div>\n//     </my-counter>\n//   )\n\n// // our Counter instance with initial props\n// const MyCounter = myCounter(Component)({seconds: 42})\n\n// // reset in 10 seconds\n// setTimeout(MyCounter._.reset, 10000)\n\n// const view = ()=>\n//   <MyCounter border=\"1px solid grey\">\n//     <h1>Hello</h1>\n//   </MyCounter>\n\n// // or we can register component as custom element\n// h.use({'my-counter': (props)=>\n//   let mkey = props && props.mkey\n//   makeMyCounter(Component)({mkey})(props)\n// })\n\n// // mkey is used as WeakMap key to cache our statefull component\n// const mkey = {uniqueObject: true}\n\n// const view = ()=>\n//   <my-counter mkey={mkey} border=\"1px solid grey\">Hello</my-counter>\n\n// ```\n\n// ## Annotated Source\n\n// We are going to use [statue](https://github.com/playframe/statue)\n// for managing state of our Component\nvar evolve, statue;\n\nevolve = require('@playframe/evolve');\n\nstatue = require('@playframe/statue');\n\n// How about using a tree of\n// [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\n// instances to cache our Component instances by `mkey`?\n// This allows us to cache our components aggresively because our `_cache`\n// will be cleaned automatically by Garbage Collector if `mkey` gets dereferenced\n\n// Let's export a higher order function that takes `sync` engine,\n// `state_actions` for statue and a pure `view` function.\nmodule.exports = (sync) => {\n  return (state_actions) => {\n    return (view) => {\n      var _cache;\n      _cache = new WeakMap;\n      return (upgrade) => {\n        var Component, _props, _rendering, _state, _v_dom, mkey, patch_shadow, render;\n        if ((mkey = upgrade && upgrade.mkey) && (Component = _cache.get(mkey))) {\n          return Component;\n        }\n        _v_dom = null;\n        _props = null;\n        _rendering = false;\n        _state = evolve(state_actions, upgrade);\n        // Creating a statue that will deliver the latest state on\n        // `sync.render` and patch shadow DOM if needed\n        _state = statue(_state, sync.render, (state) => {\n          _state = state;\n          if (!_rendering) {\n            patch_shadow();\n          }\n          _rendering = false;\n        });\n        // `patch_shadow` is responsible for producing new virtual DOM and using\n        // `patch` method for shadow DOM mutation provided by\n        // [ShaDOM](https://github.com/playframe/shadom).\n        patch_shadow = () => {\n          var patch;\n          ({patch} = _v_dom);\n          _v_dom = view(_state);\n          _v_dom.patch = patch;\n          patch(_v_dom);\n        };\n        render = () => {\n          var attr;\n          _v_dom = view(_state);\n          attr = _v_dom[1] || (_v_dom[1] = {});\n          attr.attachShadow || (attr.attachShadow = {\n            mode: 'open'\n          });\n        };\n        // Here we create our `Component` function that mimics your `view`\n        // function. But first it's checking if `props` are meant to update `_state`\n        Component = (props) => {\n          var k, v;\n          if (_v_dom) {\n            if (props !== _props) {\n// shallow equality check\n              for (k in props) {\n                v = props[k];\n                if (!(v !== _state[k])) {\n                  continue;\n                }\n                // updating state with props and rendering\n                _state = _state._(_props = props);\n                _rendering = true;\n                render();\n                break; // first run\n              }\n            }\n          } else {\n            _state = Object.assign(_state._(), _props = props);\n            render();\n          }\n          return _v_dom;\n        };\n        // Assigning high level methods from statue, adding instance to cache and our\n        // fresh `Component` is ready!\n        Component._ = _state._;\n        if (mkey) {\n          _cache.set(mkey, Component);\n        }\n        return Component;\n      };\n    };\n  };\n};\n","// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # h\n\n// ###### 0.3 kB Virtual Dom Producer\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/h\n// ```\n\n// ## Usage\n// ```js\n// import h from '@playframe/h'\n\n// // directly\n// h('a', {href: 'https://github.com/playframe/h'}, 'PlayFrame/h')\n\n// // JSX\n// const link = ()=>\n//   <a href=\"https://github.com/playframe/h\"> PlayFrame/h </a>\n// ```\n\n// ## Annotated Source\n\n// Creating a unique Symbol for distinction between Virtual Nodes\n// and plain Arrays\nvar VNODE, _registry, h, invoke;\n\nVNODE = Symbol('VNODE');\n\n_registry = {};\n\n// Our Virtual Node is produced from a list of arguments passed\n// to `h` function. Children are passed as tail of arguments,\n// but any of them could be wrapped in Array\n\n// ```js\n// h('div', {class: 's'}, child1, [ child2, child3 ], child4)`)\n// ```\n// To achieve no runtime overhead we will avoid creating a new object\n// for Virtual Node and new Array for children. We will just mark array\n// of passed arguments as a `VNODE` and return it as is.\n// This is compensated by a more advenced child walker used in\n// [@playframe/dom](https://github.com/playframe/dom)\nmodule.exports = h = (...a) => {\n  var component, name;\n  if (typeof (name = a[0]) === 'function') {\n    return invoke(...a);\n  } else if (component = _registry[name]) {\n    a[0] = component;\n    return invoke(...a);\n  } else {\n    a[VNODE] = true;\n    return a;\n  }\n};\n\nh.VNODE = VNODE;\n\n// Registering custom components like\n// `h.use({'my-component': MyComponent})`\nh.use = (components) => {\n  var k, v;\n  for (k in components) {\n    v = components[k];\n    _registry[k] = v;\n  }\n};\n\n// If the first argument of `h` function is a not a `'div'` but\n// your Component function, we will flatten the children and attach\n// them to `props`\ninvoke = (Component, props, ...children) => {\n  var child, flat, i, len;\n  if (children[0]) {\n    flat = props.children = [];\n    for (i = 0, len = children.length; i < len; i++) {\n      child = children[i];\n      if (!child[VNODE] && Array.isArray(child)) {\n        flat.push(...child);\n      } else {\n        flat.push(child);\n      }\n    }\n  }\n  return Component(props);\n};\n","// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # ShaDOM\n\n// ###### 1.5 kB DOM + Shadow DOM Manipulation\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/shadom\n// ```\n\n// ## Usage\n// ```js\n// import oversync from '@playframe/oversync'\n// import h from '@playframe/h'\n// import shadom from '@playframe/shadom'\n\n// const sync = oversync(Date.now, requestAnimationFrame)\n\n// const state = {}\n// const View = (state)=> <div></div> // h('div')\n\n// const render = shadom(sync)(document.body)\n\n// // to update DOM we do\n// render(View, state)\n// ```\n\n// ## Annotated Source\n\n// `@playframe/h` is required as peer dependency. We are importing\n// a `VNODE`\n// [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n// constant. Symbol can't be created twice in two different places.\n// It is important to use the same instance of `@playframe/h` acroass\n// your app\nvar ATTR, ELEMENT, EVENTS, FIRST_CHILD, KEYED, NAME, VNODE, _first_run, _sync, doc, emmit_remove, eventHandler, get_key, h, isArray, make_el, mutate_children, mutate_dom, patcher, remove_el, scan, set, set_attr;\n\n({VNODE} = h = require('@playframe/h'));\n\n({isArray} = Array);\n\ndoc = document;\n\n// Let's remind outselves our virtual dom data structure\n// `['div', {class: 's'}, children...]` to clarify the constants.\nNAME = 0;\n\nATTR = 1;\n\nFIRST_CHILD = 2;\n\n// Symbols are designed to assign metaproperties to existing\n// objects. Those properties are not occuring in `for` or `Object.keys`\n// iteration. They are also free from name conflicts. For example\n// different libraries can create own `Symbol('ELEMENT')` and use them\n// on the same object without any collision\nELEMENT = Symbol('ELEMENT');\n\nEVENTS = Symbol('EVENTS');\n\nKEYED = Symbol('KEYED');\n\n_sync = null;\n\n_first_run = true;\n\n// This function will schedule actual event handling at\n// the begging of the next work batch\neventHandler = (event) => {\n  var f;\n  f = event.currentTarget[EVENTS][event.type];\n  _sync.next(() => {\n    return f(event);\n  });\n};\n\n// We are exporting a higher order function that will take `sync` scheduler\n// and a `root` element. It will return a function that takes latest\n// `view` function and `state` and schedules vDOM producing and\n// DOM mutating\nmodule.exports = (sync) => {\n  return (root) => {\n    var _dom, _new_v_dom, _v_dom, render;\n    _sync = sync;\n    _v_dom = null;\n    _new_v_dom = null;\n    if (_dom = root.children[0]) {\n      _v_dom = scan(_dom);\n    }\n    render = () => {\n      _dom = mutate_dom(root, _dom, _new_v_dom, _v_dom);\n      _v_dom = _new_v_dom;\n    };\n    return (view, state) => {\n      _new_v_dom = view(state);\n      if (_first_run) { // render asap\n        render();\n        _first_run = false;\n      } else {\n        _sync.render(render);\n      }\n    };\n  };\n};\n\n// Reusing preexisting html nodes in `root` element. This will benefit\n// apps with server side pre-rendering\nscan = (el, NS) => {\n  var childNodes, i, m, ref, shadow, v_dom;\n  NS = el.namespaceURI || NS;\n  if (el.nodeType === 3) { // text\n    return el.nodeValue;\n  } else {\n    v_dom = h(el.nodeName.toLowerCase(), null);\n    ({childNodes} = (shadow = el.shadowRoot) ? (v_dom.patch = patcher(v_dom, el, shadow, NS), shadow) : el);\n    for (i = m = 0, ref = childNodes.length; m < ref; i = m += 1) {\n      v_dom.push(scan(childNodes[i]));\n    }\n    return v_dom;\n  }\n};\n\n// This function will take a DOM element `el` and its `parent` element.\n// Also it takes a new vDOM `vnode` and `old_vnode`. Their diff will\n// mutate `el`. `NS` is a XMLNS namespace for working with SVG or XHTML\nmutate_dom = (parent, el, vnode, old_vnode, NS) => {\n  var new_el, onupdate, patch, ref;\n  // console.log 'mutate_dom', vnode, old_vnode\n  if (vnode !== old_vnode) {\n    if ((old_vnode != null) && (vnode != null) && !old_vnode[VNODE] && !vnode[VNODE]) {\n      el.nodeValue = vnode; // text node\n    } else {\n      // for SVG or XHTML\n      NS = vnode && ((ref = vnode[ATTR]) != null ? ref.xmlns : void 0) || NS;\n      if ((vnode == null) || (old_vnode == null) || old_vnode[NAME] !== vnode[NAME]) {\n        // replace node\n        if (vnode != null) {\n          new_el = make_el(vnode, NS);\n          parent.insertBefore(new_el, el);\n        }\n        if (old_vnode != null) {\n          remove_el(parent, el);\n          _sync.next(() => {\n            return emmit_remove(old_vnode);\n          });\n        }\n        return new_el; // update node\n      } else {\n        if (patch = old_vnode.patch) {\n          vnode.patch = patch;\n          patch(vnode);\n        } else {\n          set_attr(el, vnode[ATTR], old_vnode[ATTR], NS);\n          mutate_children(el, vnode, old_vnode, NS);\n        }\n        if (onupdate = vnode[ATTR] && vnode[ATTR][_first_run ? 'oncreate' : 'onupdate']) {\n          onupdate(el);\n        }\n      }\n    }\n  }\n  return el;\n};\n\n// This function will compare and mutate children of given `el`.\n// Keyed updates are supported\nmutate_children = (el, vnode, old_vnode, NS) => {\n  var by_key, child, child_el, el_i, i, j, k, key, keyed, l, ll, old_child, old_key, old_keyed, replaced_el, replacement, sub_child, sub_i, sub_il, sub_j, sub_jl, v;\n  i = j = FIRST_CHILD;\n  sub_i = sub_j = sub_il = sub_jl = el_i = 0;\n  l = vnode.length;\n  ll = (old_vnode != null ? old_vnode.length : void 0) || 0;\n  by_key = false;\n  while (true) {\n    // 2 inline child walkers for performance reasons\n    // getting next child in ['div', {}, child, [child, child],...]\n    while (i <= l) {\n      child = vnode[i];\n      if ((child == null) || (child === true || child === false)) {\n        i++; // continue\n      } else if (child[VNODE] || !isArray(child)) {\n        i++;\n        break;\n      } else {\n        sub_il || (sub_il = child.length);\n        if (((sub_child = child[sub_i]) != null) && (sub_child !== true && sub_child !== false)) {\n          sub_i++;\n          child = sub_child;\n          break;\n        } else {\n          if (sub_i < sub_il) {\n            sub_i++;\n          } else {\n            sub_i = sub_il = 0;\n            i++;\n          }\n        }\n      }\n    }\n    key = get_key(child);\n    while (j <= ll) {\n      old_key = null;\n      old_child = old_vnode[j];\n      if ((old_child == null) || (old_child === true || old_child === false)) {\n        j++; // continue\n      } else if (old_child[VNODE] || !isArray(old_child)) {\n        j++;\n        old_key = get_key(old_child);\n        if (!(old_keyed && old_key && !old_keyed[old_key])) {\n          break;\n        }\n      } else {\n        sub_jl || (sub_jl = old_child.length);\n        if (((sub_child = old_child[sub_j]) != null) && (sub_child !== true && sub_child !== false)) {\n          sub_j++;\n          old_child = sub_child;\n          old_key = get_key(old_child);\n          if (!(old_keyed && old_key && !old_keyed[old_key])) {\n            break;\n          }\n        } else {\n          if (sub_j < sub_jl) {\n            sub_j++;\n          } else {\n            sub_j = sub_jl = 0;\n            j++;\n          }\n        }\n      }\n    }\n    if (!(child || old_child)) {\n      break;\n    }\n    child_el = el.childNodes[el_i];\n    if (!by_key && (key || old_key)) {\n      by_key = true; // switch to keyed mode\n      old_keyed = old_vnode && old_vnode[KEYED];\n      keyed = vnode[KEYED] = Object.create(null);\n    }\n    if (!(old_keyed && child && old_key !== key)) {\n      // direct mutation unless key mismatch\n      child_el = mutate_dom(el, child_el, child, old_child, NS);\n    } else {\n      // if there is key mismatch\n      // we will replace current dom node\n      // with an existing keyed or a new one\n      if (replacement = old_keyed[key]) {\n        replaced_el = mutate_dom(el, replacement[ELEMENT], child, replacement, NS);\n      } else {\n        replaced_el = make_el(child, NS);\n      }\n      el.insertBefore(replaced_el, child_el);\n      if (old_child) {\n        remove_el(el, child_el);\n        if (old_key) {\n          // emit remove if not reused\n          _sync.render(((old_key) => {\n            return () => { // old_key closure\n              if (old_keyed[old_key]) {\n                return emmit_remove(old_keyed[old_key]);\n              }\n            };\n          })(old_key));\n        } else {\n          emmit_remove(old_child);\n        }\n      }\n      child_el = replaced_el;\n    }\n    if (child != null) {\n      el_i++; // moving pointer to next DOM element\n      if (key) {\n        child[ELEMENT] = child_el;\n        keyed[key] = child;\n        old_keyed && (old_keyed[key] = null);\n      }\n    }\n  }\n  // end of loop\n  if (old_keyed) {\n// copying over unused cached keyed nodes\n    for (k in old_keyed) {\n      v = old_keyed[k];\n      if (v) {\n        keyed[k] = v;\n      }\n    }\n  }\n};\n\n// This function will create a new DOM element with its children\nmake_el = (vnode, NS) => {\n  var el, oncreate, shadow, shadow_props;\n  if (vnode[VNODE]) {\n    el = NS ? doc.createElementNS(NS, vnode[NAME]) : doc.createElement(vnode[NAME]);\n    set_attr(el, vnode[ATTR], null, NS);\n    if (shadow_props = vnode[ATTR] && vnode[ATTR].attachShadow) {\n      shadow = el.attachShadow(shadow_props);\n      vnode.patch = patcher(vnode, el, shadow, NS);\n      mutate_children(shadow, vnode, null, NS);\n    } else {\n      mutate_children(el, vnode, null, NS);\n    }\n    if (oncreate = vnode[ATTR] && vnode[ATTR].oncreate) {\n      oncreate(el);\n    }\n    return el;\n  } else {\n    return doc.createTextNode(vnode);\n  }\n};\n\n// Removing element from its parent\nremove_el = (parent, el) => {\n  parent.removeChild(el);\n};\n\nemmit_remove = (vnode) => {\n  var child, length, onremove;\n  ({length} = vnode);\n  while (length-- > 0) {\n    if (isArray(child = vnode[length])) {\n      emmit_remove(child);\n    }\n  }\n  if (onremove = vnode[ATTR] && vnode[ATTR].onremove) {\n    onremove();\n  }\n};\n\n// Comparing and setting attributes\nset_attr = (el, attr, old_attr, NS) => {\n  var k, old_v, v;\n  for (k in old_attr) {\n    old_v = old_attr[k];\n    if (!(attr && (attr[k] != null))) {\n      set(el, k, null, old_v, NS);\n    }\n  }\n  for (k in attr) {\n    v = attr[k];\n    old_v = k === 'value' || k === 'checked' ? el[k] : old_attr && old_attr[k];\n    if (v !== old_v) {\n      set(el, k, v, old_v, NS);\n    }\n  }\n};\n\nset = (el, name, value, old_value, NS) => {\n  var events, k, style, v;\n  if (name === 'key' || name === 'attachShadow') {\n\n  // skip\n  } else if (name === 'style') {\n    style = el[name];\n    if (typeof value === 'string') {\n      style.cssText = value;\n    } else {\n      if (typeof old_value === 'string') {\n        style.cssText = '';\n      } else {\n        value = {...value};\n        for (k in old_value) {\n          if (value[k] == null) {\n            value[k] = '';\n          }\n        }\n      }\n      for (k in value) {\n        v = value[k];\n        if (k.charCodeAt(0) === 45) { // starts with '-'\n          style.setProperty(k, v);\n        } else {\n          style[k] = v;\n        }\n      }\n    }\n  } else {\n    // starts with 'on', event listener\n    if (name.charCodeAt(0) === 111 && name.charCodeAt(1) === 110) {\n      name = name.slice(2);\n      events = el[EVENTS] || (el[EVENTS] = {});\n      old_value || (old_value = events[name]);\n      events[name] = value;\n      if (value) {\n        if (!old_value) {\n          el.addEventListener(name, eventHandler);\n        }\n      } else {\n        el.removeEventListener(name, eventHandler);\n      }\n    // attribute\n    } else if (name in el && (name !== 'list' && name !== 'type' && name !== 'draggable' && name !== 'spellcheck' && name !== 'translate') && !NS) {\n      el[name] = value != null ? value : value = '';\n    } else if ((value != null) && value !== false) {\n      el.setAttribute(name, value);\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n};\n\n// Getting a key from a virtual node\nget_key = (vnode) => {\n  return vnode && vnode[ATTR] && vnode[ATTR].key;\n};\n\n// Creating a shadow DOM `patch` function \npatcher = (_old_vnode, el, shadow, NS) => {\n  return (vnode) => {\n    if (vnode !== _old_vnode) {\n      set_attr(el, vnode[ATTR], _old_vnode[ATTR], NS);\n      mutate_children(shadow, vnode, _old_vnode, NS);\n      _old_vnode = vnode;\n    }\n  };\n};\n","// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # Router\n\n// ###### 1kB Trie Router for PlayFrame\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/router\n// ```\n\n// ## Usage\n// ```js\n// import {h, app, route, mount, Component} from '@playframe/playframe'\n\n// route({\n//   counter: 1,\n//   _: {\n//     inc: (e, state)=> state.counter++,\n//     dec: (e, state)=> state.counter--\n//   },\n//   routes: {\n//     '/': ({state})=> <a href=\"/hello/world\"><h1>Link</h1></a>,\n//     '/counter': ({state})=> CounterView(state),\n//     '/hello/:name': ({state, param})=> <h1>Hello {param.name}!</h1>,\n//     '/*': ()=>  <h1>404</h1>\n//   }\n// })(\n//   mount(document.body)\n// )\n// ```\n\n// ## Source\nvar LEAF, NAMED, WILDCARD, _404, _Page, _fallback, _href, _props, _state, _subscribed, _sync, add_methods, doc, forest, get_trie, grow_trie, isArray, make_trie, match, set_Page, subscribe, view, walk_trie;\n\ndoc = this.document;\n\n({isArray} = Array);\n\nNAMED = Symbol('NAMED');\n\nWILDCARD = Symbol('WILD');\n\nLEAF = Symbol('LEAF');\n\nforest = new WeakMap;\n\n_sync = null;\n\n_state = null;\n\n_href = null;\n\n_props = null;\n\n_Page = null;\n\n_subscribed = false;\n\n_404 = () => {\n  return 404;\n};\n\n_fallback = () => {\n  return _Page = _404;\n};\n\nmodule.exports = view = (sync) => {\n  _sync = sync;\n  return (state, l) => {\n    var href;\n    _state = state;\n    ({href} = l || (l = location));\n    if (!_subscribed && doc) {\n      subscribe();\n      _subscribed = true;\n    }\n    if (href !== _href) {\n      set_Page(l);\n    }\n    if (!state._.push) {\n      add_methods();\n    }\n    _props.state = state;\n    return _Page(_props);\n  };\n};\n\nadd_methods = () => {\n  var hop;\n  hop = () => {\n    return _sync.next(() => {\n      set_Page(location);\n      _state._({});\n      _sync.frame(() => {\n        return scrollTo(0, 0);\n      });\n    });\n  };\n  _state._.push = (href) => {\n    history.replaceState({\n      height: document.body.clientHeight\n    }, '');\n    history.pushState({}, '', href);\n    hop();\n  };\n  _state._.replace = (href) => {\n    history.replaceState({}, '', href);\n    hop();\n  };\n};\n\nsubscribe = () => {\n  doc.addEventListener(doc.ontouchstart ? 'touchstart' : 'click', (event) => {\n    var el;\n    el = (typeof event.composedPath === \"function\" ? event.composedPath()[0] : void 0) || event.target;\n    while (el && el.nodeName !== 'A') {\n      el = el.parentNode;\n    }\n    if (!el || event.button !== 0 || event.metaKey || event.altKey || event.ctrlKey || event.shiftKey || el.target === '_blank' || el.origin !== location.origin || el.getAttribute('href').startsWith('#')) {\n      return;\n    }\n    event.preventDefault();\n    return _state._.push(el.href);\n  });\n  addEventListener('popstate', ({state}) => {\n    var style;\n    ({style} = doc.body);\n    style.minHeight = `${(state != null ? state.height : void 0)}px`;\n    set_Page(location);\n    _state._({});\n    return setTimeout((() => {\n      return _sync.render(() => {\n        return style.minHeight = '';\n      });\n    }), 1000);\n  });\n};\n\nset_Page = (l) => {\n  var hash, href, i, j, k, len, pair, pathname, query, ref, search, v;\n  ({href, pathname, search, hash, query} = l);\n  _href = href;\n  if (!query) {\n    query = {};\n    ref = search.slice(1).split('&');\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      pair = ref[i];\n      [k, v] = pair.split('=');\n      query[k] = v;\n    }\n  }\n  match(get_trie(_state.routes), pathname);\n  _props = {..._props, pathname, search, query, hash};\n};\n\nget_trie = (routes) => {\n  var trie;\n  if (!(trie = forest.get(routes))) {\n    forest.set(routes, trie = make_trie(routes));\n  }\n  return trie;\n};\n\nmatch = (trie, pathname) => {\n  var param, path;\n  path = pathname.split('/');\n  param = {};\n  return walk_trie(param, trie, path, 1, _fallback);\n};\n\nwalk_trie = (param, trie, path, position, fallback) => {\n  var Page, named, step, sub_trie;\n  fallback = trie[WILDCARD] || fallback;\n  if (step = path[position]) {\n    if (sub_trie = trie[step]) {\n      walk_trie(param, sub_trie, path, position + 1, fallback);\n    } else if (named = trie[NAMED]) {\n      named(param, trie, path, position, () => {\n        return fallback(param, trie, path, position);\n      });\n    } else {\n      fallback(param, trie, path, position);\n    }\n  } else if (Page = trie[LEAF]) {\n    _props = {param};\n    _Page = Page;\n  } else {\n    fallback(param, trie, path, position);\n  }\n};\n\nmake_trie = (routes) => {\n  var k, pos, route, trie, v;\n  trie = {};\n  for (k in routes) {\n    v = routes[k];\n    route = k.split('/');\n    pos = 0;\n    if ((route[1] != null) && !route[0]) {\n      pos = 1;\n    }\n    if (typeof v === 'object') {\n      // Nested router\n      Object.assign(grow_trie(trie, route, pos), get_trie(v)); // function Page\n    } else {\n      grow_trie(trie, route, pos, v);\n    }\n  }\n  return trie;\n};\n\ngrow_trie = (trie, route, position, Page) => {\n  var first_char, name, named_trie, step;\n  if (step = route[position]) {\n    first_char = step.charCodeAt(0);\n    if (first_char === 58) { // starts with `:`\n      name = step.slice(1);\n      named_trie = trie[NAMED] || (trie[NAMED] = (param, trie, path, position, fallback) => {\n        fallback = trie[WILDCARD] || fallback;\n        param = {...param};\n        param[name] = path[position];\n        walk_trie(param, named_trie, path, position + 1, fallback);\n      });\n      return grow_trie(named_trie, route, position + 1, Page);\n    } else if (first_char === 42) { // starts with `*`\n      trie[WILDCARD] = (param, trie, path, position) => {\n        var wild;\n        wild = path.slice(position);\n        _props = {param, wild};\n        _Page = Page;\n      };\n      return trie;\n    } else {\n      return grow_trie((trie[step] || (trie[step] = {})), route, position + 1, Page);\n    }\n  } else {\n    if (Page) {\n      trie[LEAF] = Page;\n    }\n    return trie;\n  }\n};\n","// Generated by CoffeeScript 2.3.2\n// ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)\n// # PlayFrame\n\n// ###### 4 kB 60 fps Functional SPA/PWA Framework\n\n// ## Installation\n// ```sh\n// npm install --save @playframe/playframe\n// ```\n\n// ## Description\n// React + Redux alike minimalistic functional framework built on top of\n// [frame rendering engine](https://github.com/playframe/oversync)\n// to be able to update DOM 60 times per second.\n// [Stateful Web Components](https://github.com/playframe/component)\n// can rerender independetly and incaplulate styles with Shadow DOM.\n// Comes with router\n// High performance server side implementation for PWA support is coming soon\n\n// ## Usage\n// ```js\n// import {h, app, route, mount, Component} from '@playframe/playframe'\n// // SPA\n// app({\n//   //state\n//   counter: 1,\n//   // actions\n//   _: {\n//     inc: (e, state)=> state.counter++, // mutating\n//     dec: (e, {counter})=> ({counter: counter - 1}) // or returning object\n//   }\n// })( // view\n//   function CounterView(state) {\n//     return <div>\n//       <h1>Counter: {state.counter}</h1>\n//       <button onclick={state._.inc}>Increment</button>\n//       <button onclick={state._.dec}>Decrement</button>\n//     </div>\n//   }\n// )( // dom container\n//   mount(document.body)\n// )\n\n// // Or using router\n// route({\n//   counter: 1,\n//   _: {\n//     inc: (e, state)=> state.counter++,\n//     dec: (e, state)=> state.counter--\n//   },\n//   routes: {\n//     '/': ({state})=> <a href=\"/hello/world\"><h1>Link</h1></a>,\n//     '/counter': ({state})=> CounterView(state),\n//     '/hello/:name': ({state, param})=> <h1>Hello {param.name}!</h1>,\n//     '/*': ()=>  <h1>404</h1>\n//   }\n// })(\n//   mount(document.body)\n// )\n// ```\n\n// ## Docs [WIP]\n\n// ## Source\nvar app, h, router, statue, sync;\n\nsync = require('@playframe/oversync')(Date.now, requestAnimationFrame);\n\nexports.sync = sync;\n\nexports.Component = require('@playframe/component')(sync);\n\nexports.mount = require('@playframe/shadom')(sync);\n\nrouter = require('@playframe/router')(sync);\n\nexports.statue = statue = require('@playframe/statue');\n\nexports.evolve = require('@playframe/evolve');\n\nexports.app = app = (state_actions) => {\n  return (view) => {\n    return (container) => {\n      var state;\n      state_actions._ || (state_actions._ = {});\n      state = statue(state_actions, sync.finally, (state) => {\n        return container(view, state);\n      });\n      container(view, state);\n      return state;\n    };\n  };\n};\n\nexports.route = (state_actions) => {\n  return app(state_actions)(router);\n};\n\nexports.h = h = require('@playframe/h');\n\nexports.use = h.use;\n\nexports.reuse = (components) => {\n  var Component, k, purified;\n  purified = {};\n  for (k in components) {\n    Component = components[k];\n    purified[k] = (props) => {\n      var mkey;\n      mkey = props && props.mkey;\n      return Component(mkey && {mkey})(props);\n    };\n  }\n  return use(purified);\n};\n"],"names":["delta","pusher","runner","scheduler","evolve","isArray","next","f","_scheduled","g","x","task","ops","op","push","now","_prev_ts","ts","e","i","length","recover","error","console","r","Array","assign","create","is_function","keys","statue","base","upgrade","evolved","k","type","v","hasProp","hasOwnProperty","Object","state_actions","delayed","level_up","_nested","_state","action","actions","delay_nested","inject_state","reset","save_state","schedule","update_parent","update_state","_","sub_state","state","proto_state","arg","cloned","mutated","y","call","then","require$$0","require$$1","VNODE","_registry","h","invoke","Symbol","ELEMENT","EVENTS","KEYED","_first_run","_sync","doc","emmit_remove","eventHandler","get_key","make_el","mutate_children","mutate_dom","patcher","remove_el","scan","set","set_attr","a","component","name","use","components","Component","props","children","child","flat","len","document","event","currentTarget","el","NS","childNodes","m","ref","shadow","v_dom","namespaceURI","nodeType","nodeValue","nodeName","toLowerCase","shadowRoot","patch","parent","vnode","old_vnode","new_el","onupdate","xmlns","insertBefore","by_key","child_el","el_i","j","key","keyed","l","ll","old_child","old_key","old_keyed","replaced_el","replacement","sub_child","sub_i","sub_il","sub_j","sub_jl","render","oncreate","shadow_props","createElementNS","createElement","attachShadow","createTextNode","removeChild","onremove","attr","old_attr","old_v","value","old_value","events","style","cssText","charCodeAt","setProperty","slice","addEventListener","removeEventListener","setAttribute","removeAttribute","_old_vnode","LEAF","NAMED","WILDCARD","_404","_Page","_fallback","_href","_props","_subscribed","add_methods","forest","get_trie","grow_trie","make_trie","match","set_Page","subscribe","walk_trie","this","WeakMap","app","router","sync","href","location","hop","frame","scrollTo","history","replaceState","height","body","clientHeight","pushState","replace","ontouchstart","composedPath","target","parentNode","button","metaKey","altKey","ctrlKey","shiftKey","origin","getAttribute","startsWith","preventDefault","minHeight","setTimeout","hash","pair","pathname","query","search","split","routes","trie","get","path","param","position","fallback","Page","named","step","sub_trie","pos","route","first_char","named_trie","wild","steps","delta_runner","push_and_run","step_ops","steps_ops","map","run","forEach","Date","requestAnimationFrame","view","_cache","_rendering","_v_dom","mkey","patch_shadow","mode","root","_dom","_new_v_dom","require$$2","require$$3","require$$4","require$$5","container","finally","require$$6","purified"],"mappings":"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"}