(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.PlayFrame = {}));
}(this, function (exports) { 'use strict';

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # OverSync

  // ###### 0.4 kB Frame Rendering Engine

  // ## Installation
  // ```sh
  // npm install --save @playframe/oversync
  // ```

  // ## Functionality Overview
  // ```js
  // import oversync from '@playframe/oversync'

  // const sync = oversync(Date.now, requestAnimationFrame)
  // ```

  // Each method schedules given function
  // to be executed in specific time and order

  // ```js
  // sync.next(fn) // events handling and dom read
  // sync.catch(fn) // error handling
  // sync.then(fn) // data work is done here
  // sync.finally(fn) // finilizing data
  // sync.render(fn) // dom manipulation

  // // Actual requestAnimationFrame callback
  // // No work should be done here
  // sync.frame(fn)
  // ```

  // #### Execution strategy
  // Render a frame_0 first,
  // then request a new frame_1 and immediately do work.
  // After work is done VM is idling for up to 10ms
  // until frame callback is fired and frame_1 finally rendered.
  // Any event occuring after work is done
  // but before frame_1 is rendered will schedule actual work
  // to be done onlly after frame_1 is rendered

  // ```
  // 1ms Request frame_0 and setTimeout(work_for_frame_1)
  // 2ms frame_0 is rendered by browser
  // 3ms Request frame_1
  // 4ms work_for_frame_1: read dom, do work, write dom
  // ... idle
  // 8ms Click: sync.next(click_handler) for frame_2
  // ... idle
  // 10ms Fetch: sync.then(fetch_handler) for frame_2
  // ...idle
  // 15ms Animation callback: setTimeout(work_for_frame_2)
  // 16ms frame_1 is rendered
  // 17ms Request frame_2
  // 18ms work_for_frame_2: read dom, do work, write dom
  // ...
  // ```

  // ## Annotated Source
  // Let's define a higher order function
  // that would take a `now` timestamp function,
  // scheduling `next` function and optionally
  // a list `steps` of desired execution order and method names
  // and an optional `step` method name.
  var delta, pusher, runner, scheduler;

  var oversync = (now, next, steps = ['next', 'catch', 'then', 'finally', 'render'], step = 'frame') => {
    var delta_runner, push_and_run, schedule, step_ops, steps_ops, sync;
    // For each step we would prepare and empty array
    step_ops = [];
    steps_ops = steps.map(() => {
      return [];
    });
    // For measuring time deltas we would have a fancy runner function
    delta_runner = delta(now)(runner);
    // `schedule` function for requesting next frame
    // in which we would run our `frame` operations and
    // schedule work for the rest of the steps
    schedule = scheduler(next)(() => {
      var run;
      run = delta_runner();
      run(step_ops);
      return setTimeout(() => {
        return steps_ops.forEach(run);
      });
    });
    // A pusher function that will `schedule` on every push
    push_and_run = pusher(schedule);
    // Dynamically creating methods that would push operations
    // and schedule execution and returning `sync`
    sync = {};
    sync[step] = push_and_run(step_ops);
    steps.forEach((step, i) => {
      return sync[step] = push_and_run(steps_ops[i]);
    });
    return sync;
  };

  // #### Abstract functions

  // Our `scheduler` is creating a throttled `schedule`
  scheduler = (next) => {
    return (f) => {
      var _scheduled, g;
      _scheduled = false;
      g = (x) => {
        _scheduled = false;
        return f(x);
      };
      return () => {
        if (!_scheduled) {
          _scheduled = true;
          next(g);
        }
      };
    };
  };

  // This `pusher` is creating a function that will run `task`
  // before pushing `op` to `ops`
  pusher = (task) => {
    return (ops) => {
      return (op) => {
        task();
        ops.push(op);
      };
    };
  };

  // Feeding timestamps produced by `now` to a given `f`
  // like our `runner`
  delta = (now) => {
    return (f) => {
      var _prev_ts;
      _prev_ts = now();
      return () => {
        var ts;
        return f({
          delta: (ts = now()) - _prev_ts,
          ts: (_prev_ts = ts)
        });
      };
    };
  };

  // This runner will feed `x` to a list of given `ops`.
  // It will recover if any operation fails.
  // Clearing `ops` list at the end
  runner = (x) => {
    return (ops) => {
      var e, i, length, recover;
      i = 0;
      // Rechecking length in outer loop
      // could push more ops while running
      while (i < (length = ops.length)) {
        try {
          while (i < length) {
            ops[i++](x);
          }
        } catch (error) {
          e = error;
          console.error(e);
          if (recover = ops[i - 1].r) { // recovering
            recover(e);
          }
        }
      }
      ops.length = 0; // mutating ðŸ‘¹
    };
  };

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # Evolve

  // ###### 0.16 kB Deep calling assign

  // ## Installation
  // ```sh
  // npm install --save @playframe/evolve
  // ```

  // ## Usage
  // ```js
  // import evolve from '@playframe/evolve'

  // const props = {onclick: (event)=> fetch()}

  // const clickLogger = { onclick: (handler)=>(e)=>
  //   console.log(e)
  //   handler && handler(e);
  // }

  // const loggedClicksProps = evolve(props, clickLogger);
  // ```

  // ## Annotated Source

  // Caching `Array.isArray` for perf
  var evolve, isArray;

  ({isArray} = Array);

  // Exporting a deep assign that passes old values to functions
  var evolve_1 = evolve = (base, upgrade) => {
    var evolved, k, type, v;
    evolved = {...base};
    for (k in upgrade) {
      v = upgrade[k];
      type = typeof v;
      evolved[k] = type === 'function' ? v(base[k]) : type === 'object' && !isArray(v) ? evolve(base[k], v) : v;
    }
    return evolved;
  };

  // Generated by CoffeeScript 2.3.2
    // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
    // # Statue

    // ###### 0.4 kb Art of functional State

    // ## Installation
    // ```sh
    // npm install --save @playframe/statue
    // ```

    // ## Description
    // Statue is a [Redux](https://github.com/reduxjs/redux)
    // like functional state manegement library that lets you define
    // and access actions right inside of your state. So you could
    // describe a deeply nested state tree with nested actions
    // in one simple object.

    // To update state, action could return a new object
    // that has one or more properties.
    // This will produce a new state with those properties updated.

    // Another option is to mutate a state object passed to your function.
    // Mutation will be detected and this will produce a new state as well.
    // Returned value is ignored in this case.
    // If you are writing a performance demanding reducer,
    // please use this mutation trick and define the hottest property as
    // the first one in your initial state for faster checking.

    // If you don't want to update state, please make sure you action
    // returns something
    // [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)
    // or the same state that was passed to it

    // To work with state directly you can do
    // ```js
    // // to update the state
    // state._(updated)

    // // to read the latest state
    // state = state._()

    // // to turn a function into a reducer
    // state._.new_action = state._( (x, state)=> state.x = x )
    // ```
    //  Statue also cares not to send too many updates
    // from child to parent branches
    // ## Usage
    // ```js
    // import statue from '@playframe/statue'
    // const state = statue({
    //   i: 0,
    //   _: {
    //     increment: (x, state)=> i: state.i + 1,
    //     incrementBy: (n)=>(event, state)=> state.i += n // mutating
    //   },
    //   subState: {
    //     i: 0,
    //     _: {
    //       increment: (x, state)=> i: state.i + 1
    //     }
    //   }
    //   },
    //   setTimeout,
    //   (newState)=> {
    //     console.log('Counter is:', newState.i)
    //     console.log('Subcounter is:', newState.subState.i)
    //   }
    // )
    // for(let j = 0; j < 100; j++){
    //   state.subState._.increment()
    //   state.subState._.increment()
    //   state._.increment()
    // }
    // // Logs only once
    // //> Counter is: 100
    // //> Subcounter is: 200
    // // Will increment by 10 and log in console on every click
    // $('button').click( state._.incrementBy(10) )
    // ```
    // ## Annotated Source
    // Caching static functions from `Object`
  var assign, create, is_function, keys, statue,
    hasProp = {}.hasOwnProperty;

  ({assign, create, keys} = Object);

  is_function = (f) => {
    return typeof f === 'function';
  };

  // Let's define a function that takes a takes `state_actions`
  // as an initial state and its reducers (actions)
  // defined under `_` (underscore) property.
  // Our function also takes `level_up` or 'subscribe' function
  // that will be called when state updates. Most sertainly we don't
  // want to update the whole state tree every time nested leaf updates,
  // so we also pass a `delayed` function that will help debounce
  // parent update
  var statue_1 = statue = (state_actions, delayed, level_up) => {
    /*                       state._.actions
                                   ]_[.state._.actions
                                   [_]      ]_[.
                                   [_]      [_]
    */
    var _nested, _scheduled, _state, action, actions, delay_nested, inject_state, k, reset, save_state, schedule, update_parent, update_state, v;
    actions = state_actions._;
    _state = state_actions; // _closure
    _scheduled = false; // _closure
    _nested = reset = () => {
      return _nested = reset; // reset _nested
    };

    // delaying child state updates
    delay_nested = (f) => {
      _nested = ((_nested) => {
        return () => {
          _nested();
          f();
        };
      })(_nested);
      schedule();
    };
  // recursive statue if there nested actions
    for (k in state_actions) {
      v = state_actions[k];
      if (v._) {
        _state[k] = statue(v, delay_nested, ((k) => {
          return (sub_state) => { // closure for k
            return _state[k] = sub_state; // executes as _nested
          };
        })(k));
      }
    }

    // saving new state in closure
    save_state = (state) => {
      schedule();
      return _state = state;
    };
    schedule = () => {
      if (!_scheduled) {
        _scheduled = true;
        // lazy parent update
        delayed(update_parent);
      }
    };
    update_parent = () => {
      var proto_state;
      _scheduled = false;
      proto_state = _state;
      _state = create(null);
      for (k in proto_state) {
        // merging prototype chain state
        _state[k] = proto_state[k];
      }
      _nested();
      level_up(_state);
    };
    // This function is a little overloaded, it's a getter/setter but
    // also is a function wrapper.
    // You can access it like this `yourState._(updated)`.
    // The wrapper will return a twin of your function
    // that calls yours and passes a copy of latest state
    // as the second argument. State will update, if the copy is mutated
    // or a new object returned. If your function
    // returns a new function, it will be wrapped in the same manner.
    // So we support state updates for deeply curried functions.

    // curry down or make state
    _state._ = update_state = (arg) => {
      if (is_function(arg)) {
        return inject_state(arg);
      } else {
        if (arg) {
          return save_state(assign(create(_state), arg));
        } else {
          return _state;
        }
      }
    };
    // `inject_state` is a higher order function that does the magic.
    // It produces a cheap clone if current state by setting current
    // state as its prototype. Please note that such a clone has no
    // own properties, and all property accees falls back to its
    // prototype. If we mutate such a clone, new properties are
    // easily detected
    inject_state = (f) => {
      return (x) => {
        var cloned, mutated, y;
        // _state as prototype of cloned
        cloned = create(_state);
        y = f(x, cloned);
        for (k in cloned) {
          if (!hasProp.call(cloned, k)) { continue; }
          // mutation detected
          mutated = true;
          save_state(cloned);
          break;
        }
        if (is_function(y)) {
          // recursevely currying down
          return inject_state(y);
        } else {
          if (y && !mutated && y !== cloned && !y.then) { // not promise
            save_state(assign(cloned, y));
          }
          return y;
        }
      };
    };
  // Now let's wrap all of your actions and set under the `_` property.
  // That's it! You new state machine is ready!

  // bind actions to state
    for (k in actions) {
      action = actions[k];
      update_state[k] = inject_state(action);
    }
    return _state;
  };

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # Component

  // ###### 0.3 kB Pure Stateful Styled Components

  // ## Installation
  // ```sh
  // npm install --save @playframe/component
  // ```

  // ## Description
  // Pure Functional Styled Web Components for
  // [PlayFrame](https://github.com/playframe/playframe). Components are
  // rendered independetly from the rest of the app. By using
  // [Shadow DOM](https://developers.google.com/web/fundamentals/web-components/shadowdom)
  // provided by
  // [ShaDOM](https://github.com/playframe/shadom)
  // we achieve scoped styling and simple css selectors.
  // Please consider using
  // [CSS Variables](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables)
  // for maximum animation performance and flexibility.

  // You can create instances manually and keep them in parent state or
  // you can register them with `fp.use` or `h.use` and create them dynamically.
  // To be able to identify the same dynamic component we use a unique
  // object `mkey` as a
  // [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)
  // key. For a `UserView` Component actual `user` object would be a perfect
  // WeakMap key

  // ## Usage
  // ```js
  // import h from '@playframe/h'
  // import oversync from '@playframe/oversync'
  // import component from '@playframe/component'

  // const sync = oversync(Date.now, requestAnimationFrame)
  // const Component = component(sync)

  // export default myCounter = (Component)=>
  //   Component({
  //     seconds: 0,
  //     _: {
  //       reset: ()=> {seconds: 0}
  //       increment: (x, state)=> {
  //         state.seconds++
  //         setTimeout( state._.increment,
  //           (1000 - Date.now() % 1000) || 1000 )
  //       }
  //     }
  //   })((state)=>
  //     <my-counter style={ {'--border': state.border} }>
  //       <style>{`
  //         :host {
  //           display: block;
  //           border: var(--border, 0);
  //         }
  //       `}</style>
  //       <div>
  //         {props.children}
  //         <br/>
  //         {state.seconds} seconds passed
  //         <br/>
  //         <button onclick={state._.reset}> Reset </button>
  //       </div>
  //     </my-counter>
  //   )

  // // our Counter instance with initial props
  // const MyCounter = myCounter(Component)({seconds: 42})

  // // reset in 10 seconds
  // setTimeout(MyCounter._.reset, 10000)

  // const view = ()=>
  //   <MyCounter border="1px solid grey">
  //     <h1>Hello</h1>
  //   </MyCounter>

  // // or we can register component as custom element
  // h.use({'my-counter': (props)=>
  //   let mkey = props && props.mkey
  //   makeMyCounter(Component)({mkey})(props)
  // })

  // // mkey is used as WeakMap key to cache our statefull component
  // const mkey = {uniqueObject: true}

  // const view = ()=>
  //   <my-counter mkey={mkey} border="1px solid grey">Hello</my-counter>

  // ```

  // ## Annotated Source

  // We are going to use [statue](https://github.com/playframe/statue)
  // for managing state of our Component
  var evolve$1, statue$1;

  evolve$1 = evolve_1;

  statue$1 = statue_1;

  // How about using a tree of
  // [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)
  // instances to cache our Component instances by `mkey`?
  // This allows us to cache our components aggresively because our `_cache`
  // will be cleaned automatically by Garbage Collector if `mkey` gets dereferenced

  // Let's export a higher order function that takes `sync` engine,
  // `state_actions` for statue and a pure `view` function.
  var component = (sync) => {
    return (state_actions) => {
      return (view) => {
        var _cache;
        _cache = new WeakMap;
        return (upgrade) => {
          var Component, _props, _rendering, _state, _v_dom, mkey, patch_shadow, render;
          if ((mkey = upgrade && upgrade.mkey) && (Component = _cache.get(mkey))) {
            return Component;
          }
          _v_dom = null;
          _props = null;
          _rendering = false;
          _state = evolve$1(state_actions, upgrade);
          // Creating a statue that will deliver the latest state on
          // `sync.render` and patch shadow DOM if needed
          _state = statue$1(_state, sync.render, (state) => {
            _state = state;
            if (!_rendering) {
              patch_shadow();
            }
            _rendering = false;
          });
          // `patch_shadow` is responsible for producing new virtual DOM and using
          // `patch` method for shadow DOM mutation provided by
          // [ShaDOM](https://github.com/playframe/shadom).
          patch_shadow = () => {
            var patch;
            ({patch} = _v_dom);
            _v_dom = view(_state);
            _v_dom.patch = patch;
            patch(_v_dom);
          };
          render = () => {
            var attr;
            _v_dom = view(_state);
            attr = _v_dom[1] || (_v_dom[1] = {});
            attr.attachShadow || (attr.attachShadow = {
              mode: 'open'
            });
          };
          // Here we create our `Component` function that mimics your `view`
          // function. But first it's checking if `props` are meant to update `_state`
          Component = (props) => {
            var k, v;
            if (_v_dom) {
              if (props !== _props) {
  // shallow equality check
                for (k in props) {
                  v = props[k];
                  if (!(v !== _state[k])) {
                    continue;
                  }
                  // updating state with props and rendering
                  _state = _state._(_props = props);
                  _rendering = true;
                  render();
                  break; // first run
                }
              }
            } else {
              _state = Object.assign(_state._(), _props = props);
              render();
            }
            return _v_dom;
          };
          // Assigning high level methods from statue, adding instance to cache and our
          // fresh `Component` is ready!
          Component._ = _state._;
          if (mkey) {
            _cache.set(mkey, Component);
          }
          return Component;
        };
      };
    };
  };

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # h

  // ###### 0.3 kB Virtual Dom Producer

  // ## Installation
  // ```sh
  // npm install --save @playframe/h
  // ```

  // ## Usage
  // ```js
  // import h from '@playframe/h'

  // // directly
  // h('a', {href: 'https://github.com/playframe/h'}, 'PlayFrame/h')

  // // JSX
  // const link = ()=>
  //   <a href="https://github.com/playframe/h"> PlayFrame/h </a>
  // ```

  // ## Annotated Source

  // Creating a unique Symbol for distinction between Virtual Nodes
  // and plain Arrays
  var VNODE, _registry, h, invoke;

  VNODE = Symbol('VNODE');

  _registry = {};

  // Our Virtual Node is produced from a list of arguments passed
  // to `h` function. Children are passed as tail of arguments,
  // but any of them could be wrapped in Array

  // ```js
  // h('div', {class: 's'}, child1, [ child2, child3 ], child4)`)
  // ```
  // To achieve no runtime overhead we will avoid creating a new object
  // for Virtual Node and new Array for children. We will just mark array
  // of passed arguments as a `VNODE` and return it as is.
  // This is compensated by a more advenced child walker used in
  // [@playframe/dom](https://github.com/playframe/dom)
  var h_1 = h = (...a) => {
    var component, name;
    if (typeof (name = a[0]) === 'function') {
      return invoke(...a);
    } else if (component = _registry[name]) {
      a[0] = component;
      return invoke(...a);
    } else {
      a[VNODE] = true;
      return a;
    }
  };

  h.VNODE = VNODE;

  // Registering custom components like
  // `h.use({'my-component': MyComponent})`
  h.use = (components) => {
    var k, v;
    for (k in components) {
      v = components[k];
      _registry[k] = v;
    }
  };

  // If the first argument of `h` function is a not a `'div'` but
  // your Component function, we will flatten the children and attach
  // them to `props`
  invoke = (Component, props, ...children) => {
    var child, flat, i, len;
    if (children[0]) {
      flat = props.children = [];
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (!child[VNODE] && Array.isArray(child)) {
          flat.push(...child);
        } else {
          flat.push(child);
        }
      }
    }
    return Component(props);
  };

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # ShaDOM

  // ###### 1.5 kB DOM + Shadow DOM Manipulation

  // ## Installation
  // ```sh
  // npm install --save @playframe/shadom
  // ```

  // ## Usage
  // ```js
  // import oversync from '@playframe/oversync'
  // import h from '@playframe/h'
  // import shadom from '@playframe/shadom'

  // const sync = oversync(Date.now, requestAnimationFrame)

  // const state = {}
  // const View = (state)=> <div></div> // h('div')

  // const render = shadom(sync)(document.body)

  // // to update DOM we do
  // render(View, state)
  // ```

  // ## Annotated Source

  // `@playframe/h` is required as peer dependency. We are importing
  // a `VNODE`
  // [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
  // constant. Symbol can't be created twice in two different places.
  // It is important to use the same instance of `@playframe/h` acroass
  // your app
  var ATTR, ELEMENT, EVENTS, FIRST_CHILD, KEYED, NAME, VNODE$1, _first_run, _sync, doc, emmit_remove, eventHandler, get_key, h$1, isArray$1, make_el, mutate_children, mutate_dom, patcher, remove_el, scan, set, set_attr;

  ({VNODE: VNODE$1} = h$1 = h_1);

  ({isArray: isArray$1} = Array);

  doc = document;

  // Let's remind outselves our virtual dom data structure
  // `['div', {class: 's'}, children...]` to clarify the constants.
  NAME = 0;

  ATTR = 1;

  FIRST_CHILD = 2;

  // Symbols are designed to assign metaproperties to existing
  // objects. Those properties are not occuring in `for` or `Object.keys`
  // iteration. They are also free from name conflicts. For example
  // different libraries can create own `Symbol('ELEMENT')` and use them
  // on the same object without any collision
  ELEMENT = Symbol('ELEMENT');

  EVENTS = Symbol('EVENTS');

  KEYED = Symbol('KEYED');

  _sync = null;

  _first_run = true;

  // This function will schedule actual event handling at
  // the begging of the next work batch
  eventHandler = (event) => {
    var f;
    f = event.currentTarget[EVENTS][event.type];
    _sync.next(() => {
      return f(event);
    });
  };

  // We are exporting a higher order function that will take `sync` scheduler
  // and a `root` element. It will return a function that takes latest
  // `view` function and `state` and schedules vDOM producing and
  // DOM mutating
  var shadom = (sync) => {
    return (root) => {
      var _dom, _new_v_dom, _v_dom, render;
      _sync = sync;
      _v_dom = null;
      _new_v_dom = null;
      if (_dom = root.children[0]) {
        _v_dom = scan(_dom);
      }
      render = () => {
        _dom = mutate_dom(root, _dom, _new_v_dom, _v_dom);
        _v_dom = _new_v_dom;
      };
      return (view, state) => {
        _new_v_dom = view(state);
        if (_first_run) { // render asap
          render();
          _first_run = false;
        } else {
          _sync.render(render);
        }
      };
    };
  };

  // Reusing preexisting html nodes in `root` element. This will benefit
  // apps with server side pre-rendering
  scan = (el, NS) => {
    var childNodes, i, m, ref, shadow, v_dom;
    NS = el.namespaceURI || NS;
    if (el.nodeType === 3) { // text
      return el.nodeValue;
    } else {
      v_dom = h$1(el.nodeName.toLowerCase(), null);
      ({childNodes} = (shadow = el.shadowRoot) ? (v_dom.patch = patcher(v_dom, el, shadow, NS), shadow) : el);
      for (i = m = 0, ref = childNodes.length; m < ref; i = m += 1) {
        v_dom.push(scan(childNodes[i]));
      }
      return v_dom;
    }
  };

  // This function will take a DOM element `el` and its `parent` element.
  // Also it takes a new vDOM `vnode` and `old_vnode`. Their diff will
  // mutate `el`. `NS` is a XMLNS namespace for working with SVG or XHTML
  mutate_dom = (parent, el, vnode, old_vnode, NS) => {
    var new_el, onupdate, patch, ref;
    // console.log 'mutate_dom', vnode, old_vnode
    if (vnode !== old_vnode) {
      if ((old_vnode != null) && (vnode != null) && !old_vnode[VNODE$1] && !vnode[VNODE$1]) {
        el.nodeValue = vnode; // text node
      } else {
        // for SVG or XHTML
        NS = vnode && ((ref = vnode[ATTR]) != null ? ref.xmlns : void 0) || NS;
        if ((vnode == null) || (old_vnode == null) || old_vnode[NAME] !== vnode[NAME]) {
          // replace node
          if (vnode != null) {
            new_el = make_el(vnode, NS);
            parent.insertBefore(new_el, el);
          }
          if (old_vnode != null) {
            remove_el(parent, el);
            _sync.next(() => {
              return emmit_remove(old_vnode);
            });
          }
          return new_el; // update node
        } else {
          if (patch = old_vnode.patch) {
            vnode.patch = patch;
            patch(vnode);
          } else {
            set_attr(el, vnode[ATTR], old_vnode[ATTR], NS);
            mutate_children(el, vnode, old_vnode, NS);
          }
          if (onupdate = vnode[ATTR] && vnode[ATTR][_first_run ? 'oncreate' : 'onupdate']) {
            onupdate(el);
          }
        }
      }
    }
    return el;
  };

  // This function will compare and mutate children of given `el`.
  // Keyed updates are supported
  mutate_children = (el, vnode, old_vnode, NS) => {
    var by_key, child, child_el, el_i, i, j, k, key, keyed, l, ll, old_child, old_key, old_keyed, replaced_el, replacement, sub_child, sub_i, sub_il, sub_j, sub_jl, v;
    i = j = FIRST_CHILD;
    sub_i = sub_j = sub_il = sub_jl = el_i = 0;
    l = vnode.length;
    ll = (old_vnode != null ? old_vnode.length : void 0) || 0;
    by_key = false;
    while (true) {
      // 2 inline child walkers for performance reasons
      // getting next child in ['div', {}, child, [child, child],...]
      while (i <= l) {
        child = vnode[i];
        if ((child == null) || (child === true || child === false)) {
          i++; // continue
        } else if (child[VNODE$1] || !isArray$1(child)) {
          i++;
          break;
        } else {
          sub_il || (sub_il = child.length);
          if (((sub_child = child[sub_i]) != null) && (sub_child !== true && sub_child !== false)) {
            sub_i++;
            child = sub_child;
            break;
          } else {
            if (sub_i < sub_il) {
              sub_i++;
            } else {
              sub_i = sub_il = 0;
              i++;
            }
          }
        }
      }
      key = get_key(child);
      while (j <= ll) {
        old_key = null;
        old_child = old_vnode[j];
        if ((old_child == null) || (old_child === true || old_child === false)) {
          j++; // continue
        } else if (old_child[VNODE$1] || !isArray$1(old_child)) {
          j++;
          old_key = get_key(old_child);
          if (!(old_keyed && old_key && !old_keyed[old_key])) {
            break;
          }
        } else {
          sub_jl || (sub_jl = old_child.length);
          if (((sub_child = old_child[sub_j]) != null) && (sub_child !== true && sub_child !== false)) {
            sub_j++;
            old_child = sub_child;
            old_key = get_key(old_child);
            if (!(old_keyed && old_key && !old_keyed[old_key])) {
              break;
            }
          } else {
            if (sub_j < sub_jl) {
              sub_j++;
            } else {
              sub_j = sub_jl = 0;
              j++;
            }
          }
        }
      }
      if (!(child || old_child)) {
        break;
      }
      child_el = el.childNodes[el_i];
      if (!by_key && (key || old_key)) {
        by_key = true; // switch to keyed mode
        old_keyed = old_vnode && old_vnode[KEYED];
        keyed = vnode[KEYED] = Object.create(null);
      }
      if (!(old_keyed && child && old_key !== key)) {
        // direct mutation unless key mismatch
        child_el = mutate_dom(el, child_el, child, old_child, NS);
      } else {
        // if there is key mismatch
        // we will replace current dom node
        // with an existing keyed or a new one
        if (replacement = old_keyed[key]) {
          replaced_el = mutate_dom(el, replacement[ELEMENT], child, replacement, NS);
        } else {
          replaced_el = make_el(child, NS);
        }
        el.insertBefore(replaced_el, child_el);
        if (old_child) {
          remove_el(el, child_el);
          if (old_key) {
            // emit remove if not reused
            _sync.render(((old_key) => {
              return () => { // old_key closure
                if (old_keyed[old_key]) {
                  return emmit_remove(old_keyed[old_key]);
                }
              };
            })(old_key));
          } else {
            emmit_remove(old_child);
          }
        }
        child_el = replaced_el;
      }
      if (child != null) {
        el_i++; // moving pointer to next DOM element
        if (key) {
          child[ELEMENT] = child_el;
          keyed[key] = child;
          old_keyed && (old_keyed[key] = null);
        }
      }
    }
    // end of loop
    if (old_keyed) {
  // copying over unused cached keyed nodes
      for (k in old_keyed) {
        v = old_keyed[k];
        if (v) {
          keyed[k] = v;
        }
      }
    }
  };

  // This function will create a new DOM element with its children
  make_el = (vnode, NS) => {
    var el, oncreate, shadow, shadow_props;
    if (vnode[VNODE$1]) {
      el = NS ? doc.createElementNS(NS, vnode[NAME]) : doc.createElement(vnode[NAME]);
      set_attr(el, vnode[ATTR], null, NS);
      if (shadow_props = vnode[ATTR] && vnode[ATTR].attachShadow) {
        shadow = el.attachShadow(shadow_props);
        vnode.patch = patcher(vnode, el, shadow, NS);
        mutate_children(shadow, vnode, null, NS);
      } else {
        mutate_children(el, vnode, null, NS);
      }
      if (oncreate = vnode[ATTR] && vnode[ATTR].oncreate) {
        oncreate(el);
      }
      return el;
    } else {
      return doc.createTextNode(vnode);
    }
  };

  // Removing element from its parent
  remove_el = (parent, el) => {
    parent.removeChild(el);
  };

  emmit_remove = (vnode) => {
    var child, length, onremove;
    ({length} = vnode);
    while (length-- > 0) {
      if (isArray$1(child = vnode[length])) {
        emmit_remove(child);
      }
    }
    if (onremove = vnode[ATTR] && vnode[ATTR].onremove) {
      onremove();
    }
  };

  // Comparing and setting attributes
  set_attr = (el, attr, old_attr, NS) => {
    var k, old_v, v;
    for (k in old_attr) {
      old_v = old_attr[k];
      if (!(attr && (attr[k] != null))) {
        set(el, k, null, old_v, NS);
      }
    }
    for (k in attr) {
      v = attr[k];
      old_v = k === 'value' || k === 'checked' ? el[k] : old_attr && old_attr[k];
      if (v !== old_v) {
        set(el, k, v, old_v, NS);
      }
    }
  };

  set = (el, name, value, old_value, NS) => {
    var events, k, style, v;
    if (name === 'key' || name === 'attachShadow') ; else if (name === 'style') {
      style = el[name];
      if (typeof value === 'string') {
        style.cssText = value;
      } else {
        if (typeof old_value === 'string') {
          style.cssText = '';
        } else {
          value = {...value};
          for (k in old_value) {
            if (value[k] == null) {
              value[k] = '';
            }
          }
        }
        for (k in value) {
          v = value[k];
          if (k.charCodeAt(0) === 45) { // starts with '-'
            style.setProperty(k, v);
          } else {
            style[k] = v;
          }
        }
      }
    } else {
      // starts with 'on', event listener
      if (name.charCodeAt(0) === 111 && name.charCodeAt(1) === 110) {
        name = name.slice(2);
        events = el[EVENTS] || (el[EVENTS] = {});
        old_value || (old_value = events[name]);
        events[name] = value;
        if (value) {
          if (!old_value) {
            el.addEventListener(name, eventHandler);
          }
        } else {
          el.removeEventListener(name, eventHandler);
        }
      // attribute
      } else if (name in el && (name !== 'list' && name !== 'type' && name !== 'draggable' && name !== 'spellcheck' && name !== 'translate') && !NS) {
        el[name] = value != null ? value : value = '';
      } else if ((value != null) && value !== false) {
        el.setAttribute(name, value);
      } else {
        el.removeAttribute(name);
      }
    }
  };

  // Getting a key from a virtual node
  get_key = (vnode) => {
    return vnode && vnode[ATTR] && vnode[ATTR].key;
  };

  // Creating a shadow DOM `patch` function 
  patcher = (_old_vnode, el, shadow, NS) => {
    return (vnode) => {
      if (vnode !== _old_vnode) {
        set_attr(el, vnode[ATTR], _old_vnode[ATTR], NS);
        mutate_children(shadow, vnode, _old_vnode, NS);
        _old_vnode = vnode;
      }
    };
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # Router

  // ###### 1kB Trie Router for PlayFrame

  // ## Installation
  // ```sh
  // npm install --save @playframe/router
  // ```

  // ## Usage
  // ```js
  // import {h, app, route, mount, Component} from '@playframe/playframe'

  // route({
  //   counter: 1,
  //   _: {
  //     inc: (e, state)=> state.counter++,
  //     dec: (e, state)=> state.counter--
  //   },
  //   routes: {
  //     '/': ({state})=> <a href="/hello/world"><h1>Link</h1></a>,
  //     '/counter': ({state})=> CounterView(state),
  //     '/hello/:name': ({state, param})=> <h1>Hello {param.name}!</h1>,
  //     '/*': ()=>  <h1>404</h1>
  //   }
  // })(
  //   mount(document.body)
  // )
  // ```

  // ## Source
  var LEAF, NAMED, WILDCARD, _404, _Page, _fallback, _href, _props, _state, _subscribed, _sync$1, add_methods, doc$1, forest, get_trie, grow_trie, make_trie, match, set_Page, subscribe, view, walk_trie;

  doc$1 = commonjsGlobal.document;

  NAMED = Symbol('NAMED');

  WILDCARD = Symbol('WILD');

  LEAF = Symbol('LEAF');

  forest = new WeakMap;

  _sync$1 = null;

  _state = null;

  _href = null;

  _props = null;

  _Page = null;

  _subscribed = false;

  _404 = () => {
    return 404;
  };

  _fallback = () => {
    return _Page = _404;
  };

  var router = view = (sync) => {
    _sync$1 = sync;
    return (state, l) => {
      var href;
      _state = state;
      ({href} = l || (l = location));
      if (!_subscribed && doc$1) {
        subscribe();
        _subscribed = true;
      }
      if (href !== _href) {
        set_Page(l);
      }
      if (!state._.push) {
        add_methods();
      }
      _props.state = state;
      return _Page(_props);
    };
  };

  add_methods = () => {
    var hop;
    hop = () => {
      return _sync$1.next(() => {
        set_Page(location);
        _state._({});
        _sync$1.frame(() => {
          return scrollTo(0, 0);
        });
      });
    };
    _state._.push = (href) => {
      history.replaceState({
        height: document.body.clientHeight
      }, '');
      history.pushState({}, '', href);
      hop();
    };
    _state._.replace = (href) => {
      history.replaceState({}, '', href);
      hop();
    };
  };

  subscribe = () => {
    doc$1.addEventListener(doc$1.ontouchstart ? 'touchstart' : 'click', (event) => {
      var el;
      el = (typeof event.composedPath === "function" ? event.composedPath()[0] : void 0) || event.target;
      while (el && el.nodeName !== 'A') {
        el = el.parentNode;
      }
      if (!el || event.button !== 0 || event.metaKey || event.altKey || event.ctrlKey || event.shiftKey || el.target === '_blank' || el.origin !== location.origin || el.getAttribute('href').startsWith('#')) {
        return;
      }
      event.preventDefault();
      return _state._.push(el.href);
    });
    addEventListener('popstate', ({state}) => {
      var style;
      ({style} = doc$1.body);
      style.minHeight = `${(state != null ? state.height : void 0)}px`;
      set_Page(location);
      _state._({});
      return setTimeout((() => {
        return _sync$1.render(() => {
          return style.minHeight = '';
        });
      }), 1000);
    });
  };

  set_Page = (l) => {
    var hash, href, i, j, k, len, pair, pathname, query, ref, search, v;
    ({href, pathname, search, hash, query} = l);
    _href = href;
    if (!query) {
      query = {};
      ref = search.slice(1).split('&');
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        pair = ref[i];
        [k, v] = pair.split('=');
        query[k] = v;
      }
    }
    match(get_trie(_state.routes), pathname);
    _props = {..._props, pathname, search, query, hash};
  };

  get_trie = (routes) => {
    var trie;
    if (!(trie = forest.get(routes))) {
      forest.set(routes, trie = make_trie(routes));
    }
    return trie;
  };

  match = (trie, pathname) => {
    var param, path;
    path = pathname.split('/');
    param = {};
    return walk_trie(param, trie, path, 1, _fallback);
  };

  walk_trie = (param, trie, path, position, fallback) => {
    var Page, named, step, sub_trie;
    fallback = trie[WILDCARD] || fallback;
    if (step = path[position]) {
      if (sub_trie = trie[step]) {
        walk_trie(param, sub_trie, path, position + 1, fallback);
      } else if (named = trie[NAMED]) {
        named(param, trie, path, position, () => {
          return fallback(param, trie, path, position);
        });
      } else {
        fallback(param, trie, path, position);
      }
    } else if (Page = trie[LEAF]) {
      _props = {param};
      _Page = Page;
    } else {
      fallback(param, trie, path, position);
    }
  };

  make_trie = (routes) => {
    var k, pos, route, trie, v;
    trie = {};
    for (k in routes) {
      v = routes[k];
      route = k.split('/');
      pos = 0;
      if ((route[1] != null) && !route[0]) {
        pos = 1;
      }
      if (typeof v === 'object') {
        // Nested router
        Object.assign(grow_trie(trie, route, pos), get_trie(v)); // function Page
      } else {
        grow_trie(trie, route, pos, v);
      }
    }
    return trie;
  };

  grow_trie = (trie, route, position, Page) => {
    var first_char, name, named_trie, step;
    if (step = route[position]) {
      first_char = step.charCodeAt(0);
      if (first_char === 58) { // starts with `:`
        name = step.slice(1);
        named_trie = trie[NAMED] || (trie[NAMED] = (param, trie, path, position, fallback) => {
          fallback = trie[WILDCARD] || fallback;
          param = {...param};
          param[name] = path[position];
          walk_trie(param, named_trie, path, position + 1, fallback);
        });
        return grow_trie(named_trie, route, position + 1, Page);
      } else if (first_char === 42) { // starts with `*`
        trie[WILDCARD] = (param, trie, path, position) => {
          var wild;
          wild = path.slice(position);
          _props = {param, wild};
          _Page = Page;
        };
        return trie;
      } else {
        return grow_trie((trie[step] || (trie[step] = {})), route, position + 1, Page);
      }
    } else {
      if (Page) {
        trie[LEAF] = Page;
      }
      return trie;
    }
  };

  // Generated by CoffeeScript 2.3.2
  // ![PlayFrame](https://avatars3.githubusercontent.com/u/47147479)
  // # PlayFrame

  // ###### 4 kB 60 fps Functional SPA/PWA Framework

  // ## Installation
  // ```sh
  // npm install --save @playframe/playframe
  // ```

  // ## Description
  // React + Redux alike minimalistic functional framework built on top of
  // [frame rendering engine](https://github.com/playframe/oversync)
  // to be able to update DOM 60 times per second.
  // [Stateful Web Components](https://github.com/playframe/component)
  // can rerender independetly and incaplulate styles with Shadow DOM.
  // Comes with router
  // High performance server side implementation for PWA support is coming soon

  // ## Usage
  // ```js
  // import {h, app, route, mount, Component} from '@playframe/playframe'
  // // SPA
  // app({
  //   //state
  //   counter: 1,
  //   // actions
  //   _: {
  //     inc: (e, state)=> state.counter++, // mutating
  //     dec: (e, {counter})=> ({counter: counter - 1}) // or returning object
  //   }
  // })( // view
  //   function CounterView(state) {
  //     return <div>
  //       <h1>Counter: {state.counter}</h1>
  //       <button onclick={state._.inc}>Increment</button>
  //       <button onclick={state._.dec}>Decrement</button>
  //     </div>
  //   }
  // )( // dom container
  //   mount(document.body)
  // )

  // // Or using router
  // route({
  //   counter: 1,
  //   _: {
  //     inc: (e, state)=> state.counter++,
  //     dec: (e, state)=> state.counter--
  //   },
  //   routes: {
  //     '/': ({state})=> <a href="/hello/world"><h1>Link</h1></a>,
  //     '/counter': ({state})=> CounterView(state),
  //     '/hello/:name': ({state, param})=> <h1>Hello {param.name}!</h1>,
  //     '/*': ()=>  <h1>404</h1>
  //   }
  // })(
  //   mount(document.body)
  // )
  // ```

  // ## Docs [WIP]

  // ## Source
  var app, h$2, router$1, statue$2, sync;

  sync = oversync(Date.now, requestAnimationFrame);

  var sync_1 = sync;

  var Component = component(sync);

  var mount = shadom(sync);

  router$1 = router(sync);

  var statue_1$1 = statue$2 = statue_1;

  var evolve$2 = evolve_1;

  var app_1 = app = (state_actions) => {
    return (view) => {
      return (container) => {
        var state;
        state_actions._ || (state_actions._ = {});
        state = statue$2(state_actions, sync.finally, (state) => {
          return container(view, state);
        });
        container(view, state);
        return state;
      };
    };
  };

  var route = (state_actions) => {
    return app(state_actions)(router$1);
  };

  var h_1$1 = h$2 = h_1;

  var use_1 = h$2.use;

  var reuse = (components) => {
    var Component, k, purified;
    purified = {};
    for (k in components) {
      Component = components[k];
      purified[k] = (props) => {
        var mkey;
        mkey = props && props.mkey;
        return Component(mkey && {mkey})(props);
      };
    }
    return use(purified);
  };

  var playframe = {
  	sync: sync_1,
  	Component: Component,
  	mount: mount,
  	statue: statue_1$1,
  	evolve: evolve$2,
  	app: app_1,
  	route: route,
  	h: h_1$1,
  	use: use_1,
  	reuse: reuse
  };

  exports.Component = Component;
  exports.app = app_1;
  exports.default = playframe;
  exports.evolve = evolve$2;
  exports.h = h_1$1;
  exports.mount = mount;
  exports.reuse = reuse;
  exports.route = route;
  exports.statue = statue_1$1;
  exports.sync = sync_1;
  exports.use = use_1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=playframe.js.map
